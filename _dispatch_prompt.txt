Build an ATS-first architecture for Mater-Browser. This replaces the "throw everything at Claude" approach with deterministic handlers.

## Overview

80% of job applications go through 5 ATS systems: Workday, Greenhouse, Lever, iCIMS, Taleo (and Phenom, SmartRecruiters). Each has predictable flows. We use pattern matching and pre-built selectors instead of AI guessing.

## Directory Structure

Create new directory: `src/ats/`

```
src/ats/
├── __init__.py
├── detector.py          # Identifies which ATS from URL/page
├── base_handler.py      # Abstract base class for all handlers
├── field_mapper.py      # Maps profile fields to ATS field names
├── registry.py          # Registry of all handlers
├── handlers/
│   ├── __init__.py
│   ├── workday.py
│   ├── greenhouse.py
│   ├── lever.py
│   ├── icims.py
│   ├── phenom.py
│   └── smartrecruiters.py
└── fallback.py          # Claude fallback for unknown ATS
```

## File: src/ats/detector.py

```python
"""ATS detection from URL patterns and page signatures."""
import logging
import re
from enum import Enum
from typing import Optional
from playwright.sync_api import Page

logger = logging.getLogger(__name__)


class ATSType(Enum):
    """Known ATS systems."""
    WORKDAY = "workday"
    GREENHOUSE = "greenhouse"
    LEVER = "lever"
    ICIMS = "icims"
    PHENOM = "phenom"
    SMARTRECRUITERS = "smartrecruiters"
    TALEO = "taleo"
    INDEED_EASY = "indeed_easy"
    LINKEDIN_EASY = "linkedin_easy"
    UNKNOWN = "unknown"


# URL patterns for each ATS
ATS_URL_PATTERNS: dict[ATSType, list[str]] = {
    ATSType.WORKDAY: [
        r"myworkdayjobs\.com",
        r"wd\d+\.myworkday\.com",
        r"workday\.com/.*recruit",
    ],
    ATSType.GREENHOUSE: [
        r"boards\.greenhouse\.io",
        r"job-boards\.greenhouse\.io",
        r"greenhouse\.io/.*jobs",
    ],
    ATSType.LEVER: [
        r"jobs\.lever\.co",
        r"lever\.co/.*apply",
    ],
    ATSType.ICIMS: [
        r"careers-.*\.icims\.com",
        r"\.icims\.com/jobs",
    ],
    ATSType.PHENOM: [
        r"phenom\.com",
        r"/us/en/job/",  # Common Phenom URL pattern
        r"/careers-home/jobs/",
    ],
    ATSType.SMARTRECRUITERS: [
        r"jobs\.smartrecruiters\.com",
        r"smartrecruiters\.com/.*jobs",
    ],
    ATSType.TALEO: [
        r"taleo\.net",
        r"\.taleo\.net/careersection",
    ],
    ATSType.INDEED_EASY: [
        r"smartapply\.indeed\.com",
        r"indeed\.com/applystart",
    ],
    ATSType.LINKEDIN_EASY: [
        r"linkedin\.com/jobs/view/.*/apply",
    ],
}

# Page signatures (DOM elements that identify the ATS)
ATS_PAGE_SIGNATURES: dict[ATSType, list[str]] = {
    ATSType.WORKDAY: [
        '[data-automation-id="workday"]',
        '[class*="workday"]',
        'form[data-automation-id]',
    ],
    ATSType.GREENHOUSE: [
        '#grnhse_app',
        '[class*="greenhouse"]',
        'form#application_form',
    ],
    ATSType.LEVER: [
        '[class*="lever"]',
        'form.application-form',
        '[data-qa="application-form"]',
    ],
    ATSType.ICIMS: [
        '[class*="icims"]',
        '#iCIMS_Content',
        'form.iCIMS_Form',
    ],
    ATSType.PHENOM: [
        '[class*="phenom"]',
        '[data-ph-at-id]',
        '.ph-form-container',
    ],
}


class ATSDetector:
    """Detects ATS system from URL and page content."""

    def __init__(self, page: Page) -> None:
        self._page = page

    def detect(self) -> ATSType:
        """Detect ATS type from current page."""
        url = self._page.url.lower()
        
        # First try URL patterns
        for ats_type, patterns in ATS_URL_PATTERNS.items():
            for pattern in patterns:
                if re.search(pattern, url, re.IGNORECASE):
                    logger.info(f"ATS detected via URL: {ats_type.value}")
                    return ats_type
        
        # Then try page signatures
        for ats_type, selectors in ATS_PAGE_SIGNATURES.items():
            for selector in selectors:
                try:
                    if self._page.locator(selector).count() > 0:
                        logger.info(f"ATS detected via signature: {ats_type.value}")
                        return ats_type
                except Exception:
                    continue
        
        logger.info("ATS type: unknown")
        return ATSType.UNKNOWN
```

## File: src/ats/field_mapper.py

```python
"""Maps profile fields to ATS-specific field names."""
from typing import Any, Optional


class FieldMapper:
    """Maps generic profile fields to ATS-specific field names."""

    # Generic field name -> ATS-specific field names
    FIELD_MAPPINGS: dict[str, dict[str, list[str]]] = {
        "first_name": {
            "workday": ["firstName", "legalNameSection_firstName"],
            "greenhouse": ["first_name", "firstName"],
            "lever": ["name", "first_name"],
            "icims": ["firstName", "Contact_Information_firstname"],
            "phenom": ["firstName", "first-name"],
            "default": ["first_name", "firstName", "fname", "first"],
        },
        "last_name": {
            "workday": ["lastName", "legalNameSection_lastName"],
            "greenhouse": ["last_name", "lastName"],
            "lever": ["name", "last_name"],
            "icims": ["lastName", "Contact_Information_lastname"],
            "phenom": ["lastName", "last-name"],
            "default": ["last_name", "lastName", "lname", "last"],
        },
        "email": {
            "workday": ["email", "emailAddress"],
            "greenhouse": ["email"],
            "lever": ["email"],
            "icims": ["email", "Contact_Information_email"],
            "phenom": ["email", "emailAddress"],
            "default": ["email", "emailAddress", "e-mail"],
        },
        "phone": {
            "workday": ["phone", "phoneNumber", "mobilePhone"],
            "greenhouse": ["phone"],
            "lever": ["phone"],
            "icims": ["phone", "Contact_Information_phone"],
            "phenom": ["phone", "phoneNumber"],
            "default": ["phone", "phoneNumber", "telephone", "mobile"],
        },
        "city": {
            "workday": ["city", "addressSection_city"],
            "greenhouse": ["city"],
            "icims": ["city", "Contact_Information_city"],
            "phenom": ["city"],
            "default": ["city"],
        },
        "state": {
            "workday": ["state", "addressSection_state", "region"],
            "greenhouse": ["state"],
            "icims": ["state"],
            "phenom": ["state", "region"],
            "default": ["state", "region", "province"],
        },
        "zip": {
            "workday": ["postalCode", "addressSection_postalCode"],
            "greenhouse": ["zip", "postal_code"],
            "icims": ["postalCode", "zip"],
            "phenom": ["postalCode", "zipCode"],
            "default": ["zip", "zipCode", "postalCode", "postal"],
        },
        "country": {
            "workday": ["country", "addressSection_country"],
            "greenhouse": ["country"],
            "icims": ["country"],
            "phenom": ["country"],
            "default": ["country"],
        },
        "linkedin_url": {
            "workday": ["linkedIn", "linkedInUrl"],
            "greenhouse": ["linkedin_url", "linkedin"],
            "lever": ["urls[LinkedIn]", "linkedin"],
            "icims": ["linkedIn"],
            "phenom": ["linkedIn", "linkedin"],
            "default": ["linkedin", "linkedIn", "linkedin_url"],
        },
        "resume": {
            "workday": ["resume", "uploadedResume"],
            "greenhouse": ["resume", "resume_file"],
            "lever": ["resume"],
            "icims": ["resume", "resumeUpload"],
            "phenom": ["resume", "resumeFile"],
            "default": ["resume", "cv", "resumeUpload"],
        },
    }

    def __init__(self, ats_type: str) -> None:
        self._ats_type = ats_type.lower()

    def get_field_names(self, generic_name: str) -> list[str]:
        """Get ATS-specific field names for a generic field."""
        mapping = self.FIELD_MAPPINGS.get(generic_name, {})
        return mapping.get(self._ats_type, mapping.get("default", [generic_name]))

    def map_profile(self, profile: dict[str, Any]) -> dict[str, Any]:
        """Map entire profile to ATS-specific field names."""
        mapped = {}
        for key, value in profile.items():
            field_names = self.get_field_names(key)
            for name in field_names:
                mapped[name] = value
        return mapped
```

## File: src/ats/base_handler.py

```python
"""Base class for ATS handlers."""
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional

from playwright.sync_api import Page

logger = logging.getLogger(__name__)


class FormPage(Enum):
    """Types of pages in an application flow."""
    JOB_LISTING = "job_listing"
    LOGIN = "login"
    PERSONAL_INFO = "personal_info"
    EXPERIENCE = "experience"
    EDUCATION = "education"
    QUESTIONS = "questions"
    DOCUMENTS = "documents"
    REVIEW = "review"
    CONFIRMATION = "confirmation"
    UNKNOWN = "unknown"


@dataclass
class PageResult:
    """Result of processing a page."""
    success: bool
    page_type: FormPage
    message: str
    needs_next_page: bool = True


class BaseATSHandler(ABC):
    """Abstract base class for ATS-specific handlers."""

    # Override in subclasses
    ATS_NAME: str = "base"
    
    # Selectors for common elements - override in subclasses
    APPLY_BUTTON_SELECTORS: list[str] = []
    NEXT_BUTTON_SELECTORS: list[str] = []
    SUBMIT_BUTTON_SELECTORS: list[str] = []

    def __init__(self, page: Page, profile: dict, resume_path: Optional[str] = None) -> None:
        self._page = page
        self._profile = profile
        self._resume_path = resume_path

    @abstractmethod
    def detect_page_type(self) -> FormPage:
        """Detect what type of page we're on."""
        pass

    @abstractmethod
    def fill_current_page(self) -> PageResult:
        """Fill all fields on the current page."""
        pass

    def click_apply(self) -> bool:
        """Click the Apply button."""
        return self._click_first_visible(self.APPLY_BUTTON_SELECTORS)

    def click_next(self) -> bool:
        """Click the Next/Continue button."""
        return self._click_first_visible(self.NEXT_BUTTON_SELECTORS)

    def click_submit(self) -> bool:
        """Click the final Submit button."""
        return self._click_first_visible(self.SUBMIT_BUTTON_SELECTORS)

    def _click_first_visible(self, selectors: list[str]) -> bool:
        """Click the first visible element from a list of selectors."""
        for selector in selectors:
            try:
                loc = self._page.locator(selector).first
                if loc.is_visible(timeout=2000):
                    loc.click()
                    logger.info(f"{self.ATS_NAME}: Clicked {selector}")
                    self._page.wait_for_timeout(1000)
                    return True
            except Exception:
                continue
        return False

    def _fill_field(self, selectors: list[str], value: str) -> bool:
        """Fill a field using the first matching selector."""
        for selector in selectors:
            try:
                loc = self._page.locator(selector).first
                if loc.is_visible(timeout=1000):
                    loc.clear()
                    loc.fill(value)
                    logger.info(f"{self.ATS_NAME}: Filled {selector}")
                    return True
            except Exception:
                continue
        return False

    def _select_option(self, selectors: list[str], value: str) -> bool:
        """Select an option from a dropdown."""
        for selector in selectors:
            try:
                loc = self._page.locator(selector).first
                if loc.is_visible(timeout=1000):
                    loc.select_option(label=value)
                    logger.info(f"{self.ATS_NAME}: Selected {value} in {selector}")
                    return True
            except Exception:
                continue
        return False

    def _upload_file(self, selectors: list[str], file_path: str) -> bool:
        """Upload a file to the first matching file input."""
        for selector in selectors:
            try:
                loc = self._page.locator(selector).first
                if loc.count() > 0:
                    loc.set_input_files(file_path)
                    logger.info(f"{self.ATS_NAME}: Uploaded to {selector}")
                    return True
            except Exception:
                continue
        return False

    def _check_checkbox(self, selectors: list[str]) -> bool:
        """Check a checkbox."""
        for selector in selectors:
            try:
                loc = self._page.locator(selector).first
                if loc.is_visible(timeout=1000):
                    if not loc.is_checked():
                        loc.check()
                    logger.info(f"{self.ATS_NAME}: Checked {selector}")
                    return True
            except Exception:
                continue
        return False

    def _is_visible(self, selector: str, timeout: int = 1000) -> bool:
        """Check if an element is visible."""
        try:
            return self._page.locator(selector).first.is_visible(timeout=timeout)
        except Exception:
            return False

    def _wait(self, ms: int = 1000) -> None:
        """Wait for specified milliseconds."""
        self._page.wait_for_timeout(ms)
```

## File: src/ats/handlers/workday.py

```python
"""Workday ATS handler."""
import logging
from typing import Optional

from playwright.sync_api import Page

from ..base_handler import BaseATSHandler, FormPage, PageResult

logger = logging.getLogger(__name__)


class WorkdayHandler(BaseATSHandler):
    """Handler for Workday ATS applications."""

    ATS_NAME = "workday"

    APPLY_BUTTON_SELECTORS = [
        '[data-automation-id="jobPostingApplyButton"]',
        'button[data-automation-id="applyButton"]',
        'a[data-automation-id="applyButton"]',
        'button:has-text("Apply")',
    ]

    NEXT_BUTTON_SELECTORS = [
        '[data-automation-id="bottom-navigation-next-button"]',
        '[data-automation-id="nextButton"]',
        'button:has-text("Next")',
        'button:has-text("Continue")',
    ]

    SUBMIT_BUTTON_SELECTORS = [
        '[data-automation-id="bottom-navigation-submit-button"]',
        '[data-automation-id="submitButton"]',
        'button:has-text("Submit")',
    ]

    # Field selectors for Workday
    FIELD_SELECTORS = {
        "first_name": [
            '[data-automation-id="legalNameSection_firstName"]',
            'input[data-automation-id="firstName"]',
        ],
        "last_name": [
            '[data-automation-id="legalNameSection_lastName"]',
            'input[data-automation-id="lastName"]',
        ],
        "email": [
            '[data-automation-id="email"]',
            'input[data-automation-id="emailAddress"]',
        ],
        "phone": [
            '[data-automation-id="phone-number"]',
            'input[data-automation-id="phoneNumber"]',
        ],
        "address": [
            '[data-automation-id="addressSection_addressLine1"]',
        ],
        "city": [
            '[data-automation-id="addressSection_city"]',
        ],
        "state": [
            '[data-automation-id="addressSection_countryRegion"]',
        ],
        "postal_code": [
            '[data-automation-id="addressSection_postalCode"]',
        ],
        "country": [
            '[data-automation-id="addressSection_country"]',
        ],
        "resume": [
            'input[data-automation-id="file-upload-input-ref"]',
            '[data-automation-id="resumeUpload"] input[type="file"]',
        ],
        "linkedin": [
            '[data-automation-id="linkedInUrl"]',
            'input[placeholder*="linkedin"]',
        ],
    }

    PAGE_INDICATORS = {
        FormPage.JOB_LISTING: [
            '[data-automation-id="jobPostingHeader"]',
            '[data-automation-id="jobPostingApplyButton"]',
        ],
        FormPage.PERSONAL_INFO: [
            '[data-automation-id="legalNameSection"]',
            '[data-automation-id="contactInformationSection"]',
        ],
        FormPage.EXPERIENCE: [
            '[data-automation-id="workExperienceSection"]',
            '[data-automation-id="Add Work Experience"]',
        ],
        FormPage.EDUCATION: [
            '[data-automation-id="educationSection"]',
            '[data-automation-id="Add Education"]',
        ],
        FormPage.DOCUMENTS: [
            '[data-automation-id="resumeSection"]',
            '[data-automation-id="file-upload"]',
        ],
        FormPage.REVIEW: [
            '[data-automation-id="reviewSection"]',
            'text="Review your application"',
        ],
        FormPage.CONFIRMATION: [
            '[data-automation-id="applicationSuccessMessage"]',
            'text="Application submitted"',
            'text="Thank you"',
        ],
    }

    def detect_page_type(self) -> FormPage:
        """Detect current Workday page type."""
        for page_type, selectors in self.PAGE_INDICATORS.items():
            for selector in selectors:
                if self._is_visible(selector, timeout=500):
                    logger.info(f"Workday page type: {page_type.value}")
                    return page_type
        return FormPage.UNKNOWN

    def fill_current_page(self) -> PageResult:
        """Fill all fields on the current Workday page."""
        page_type = self.detect_page_type()

        if page_type == FormPage.JOB_LISTING:
            return self._handle_job_listing()
        elif page_type == FormPage.PERSONAL_INFO:
            return self._handle_personal_info()
        elif page_type == FormPage.EXPERIENCE:
            return self._handle_experience()
        elif page_type == FormPage.DOCUMENTS:
            return self._handle_documents()
        elif page_type == FormPage.REVIEW:
            return self._handle_review()
        elif page_type == FormPage.CONFIRMATION:
            return PageResult(True, page_type, "Application submitted", False)
        else:
            return self._handle_unknown()

    def _handle_job_listing(self) -> PageResult:
        """Click Apply on job listing page."""
        if self.click_apply():
            self._wait(2000)
            return PageResult(True, FormPage.JOB_LISTING, "Clicked Apply", True)
        return PageResult(False, FormPage.JOB_LISTING, "Could not find Apply button", False)

    def _handle_personal_info(self) -> PageResult:
        """Fill personal information fields."""
        filled = 0

        if self._fill_field(self.FIELD_SELECTORS["first_name"], self._profile.get("first_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["last_name"], self._profile.get("last_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["email"], self._profile.get("email", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["phone"], self._profile.get("phone", "")):
            filled += 1

        # Location fields
        location = self._profile.get("location", "")
        if location:
            parts = location.split(",")
            if len(parts) >= 1:
                self._fill_field(self.FIELD_SELECTORS["city"], parts[0].strip())
            if len(parts) >= 2:
                self._fill_field(self.FIELD_SELECTORS["state"], parts[1].strip())

        if self._fill_field(self.FIELD_SELECTORS["linkedin"], self._profile.get("linkedin_url", "")):
            filled += 1

        if self.click_next():
            return PageResult(True, FormPage.PERSONAL_INFO, f"Filled {filled} fields", True)
        return PageResult(False, FormPage.PERSONAL_INFO, "Could not click Next", False)

    def _handle_experience(self) -> PageResult:
        """Handle work experience page - usually can skip if resume uploaded."""
        # Most Workday instances let you skip manual experience entry if resume uploaded
        if self.click_next():
            return PageResult(True, FormPage.EXPERIENCE, "Skipped experience (resume uploaded)", True)
        return PageResult(False, FormPage.EXPERIENCE, "Could not advance", False)

    def _handle_documents(self) -> PageResult:
        """Upload resume."""
        if self._resume_path:
            self._upload_file(self.FIELD_SELECTORS["resume"], self._resume_path)
            self._wait(2000)

        if self.click_next():
            return PageResult(True, FormPage.DOCUMENTS, "Resume uploaded", True)
        return PageResult(False, FormPage.DOCUMENTS, "Could not advance", False)

    def _handle_review(self) -> PageResult:
        """Submit the application."""
        # Check any required checkboxes
        self._check_checkbox(['input[type="checkbox"]'])
        
        if self.click_submit():
            self._wait(3000)
            return PageResult(True, FormPage.REVIEW, "Application submitted", False)
        return PageResult(False, FormPage.REVIEW, "Could not submit", False)

    def _handle_unknown(self) -> PageResult:
        """Handle unknown page type - try to advance."""
        if self.click_next():
            return PageResult(True, FormPage.UNKNOWN, "Advanced to next page", True)
        if self.click_submit():
            return PageResult(True, FormPage.UNKNOWN, "Submitted application", False)
        return PageResult(False, FormPage.UNKNOWN, "Could not determine page type", False)
```

## File: src/ats/handlers/greenhouse.py

```python
"""Greenhouse ATS handler."""
import logging

from playwright.sync_api import Page

from ..base_handler import BaseATSHandler, FormPage, PageResult

logger = logging.getLogger(__name__)


class GreenhouseHandler(BaseATSHandler):
    """Handler for Greenhouse ATS applications."""

    ATS_NAME = "greenhouse"

    APPLY_BUTTON_SELECTORS = [
        '#grnhse_app button:has-text("Apply")',
        'a:has-text("Apply for this job")',
        'button:has-text("Apply Now")',
    ]

    NEXT_BUTTON_SELECTORS = [
        'button[type="submit"]',
        'input[type="submit"]',
        'button:has-text("Submit Application")',
        'button:has-text("Submit")',
    ]

    SUBMIT_BUTTON_SELECTORS = NEXT_BUTTON_SELECTORS  # Greenhouse is usually single page

    FIELD_SELECTORS = {
        "first_name": [
            '#first_name',
            'input[name="first_name"]',
            'input[autocomplete="given-name"]',
        ],
        "last_name": [
            '#last_name',
            'input[name="last_name"]',
            'input[autocomplete="family-name"]',
        ],
        "email": [
            '#email',
            'input[name="email"]',
            'input[type="email"]',
        ],
        "phone": [
            '#phone',
            'input[name="phone"]',
            'input[type="tel"]',
        ],
        "resume": [
            'input[type="file"][name*="resume"]',
            '#resume_file',
            'input[data-field="resume"]',
        ],
        "cover_letter": [
            'input[type="file"][name*="cover"]',
            '#cover_letter_file',
        ],
        "linkedin": [
            'input[name*="linkedin"]',
            'input[placeholder*="LinkedIn"]',
        ],
        "website": [
            'input[name*="website"]',
            'input[name*="portfolio"]',
        ],
        "location": [
            'input[name*="location"]',
            '#location',
        ],
    }

    PAGE_INDICATORS = {
        FormPage.JOB_LISTING: [
            '#grnhse_app',
            '.job-post',
        ],
        FormPage.PERSONAL_INFO: [
            '#application_form',
            'form.application-form',
        ],
        FormPage.CONFIRMATION: [
            '.success-message',
            'text="Application submitted"',
            'text="Thank you for applying"',
        ],
    }

    def detect_page_type(self) -> FormPage:
        """Detect current Greenhouse page type."""
        # Check for confirmation first
        for selector in self.PAGE_INDICATORS[FormPage.CONFIRMATION]:
            if self._is_visible(selector, timeout=500):
                return FormPage.CONFIRMATION

        # Check for form
        for selector in self.PAGE_INDICATORS[FormPage.PERSONAL_INFO]:
            if self._is_visible(selector, timeout=500):
                return FormPage.PERSONAL_INFO

        return FormPage.JOB_LISTING

    def fill_current_page(self) -> PageResult:
        """Fill Greenhouse application form."""
        page_type = self.detect_page_type()

        if page_type == FormPage.CONFIRMATION:
            return PageResult(True, page_type, "Application submitted", False)

        if page_type == FormPage.JOB_LISTING:
            # Greenhouse usually shows form inline, but might have separate apply button
            if self.click_apply():
                self._wait(1500)

        return self._fill_application_form()

    def _fill_application_form(self) -> PageResult:
        """Fill the main application form."""
        filled = 0

        # Basic info
        if self._fill_field(self.FIELD_SELECTORS["first_name"], self._profile.get("first_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["last_name"], self._profile.get("last_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["email"], self._profile.get("email", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["phone"], self._profile.get("phone", "")):
            filled += 1

        # Optional fields
        self._fill_field(self.FIELD_SELECTORS["linkedin"], self._profile.get("linkedin_url", ""))
        self._fill_field(self.FIELD_SELECTORS["website"], self._profile.get("portfolio_url", ""))
        self._fill_field(self.FIELD_SELECTORS["location"], self._profile.get("location", ""))

        # Resume upload
        if self._resume_path:
            self._upload_file(self.FIELD_SELECTORS["resume"], self._resume_path)
            self._wait(1500)

        # Handle any custom questions (dropdowns, checkboxes)
        self._handle_custom_questions()

        # Submit
        if self.click_submit():
            self._wait(3000)
            # Check if we reached confirmation
            if self.detect_page_type() == FormPage.CONFIRMATION:
                return PageResult(True, FormPage.PERSONAL_INFO, "Application submitted", False)
            return PageResult(True, FormPage.PERSONAL_INFO, f"Filled {filled} fields, submitted", True)

        return PageResult(False, FormPage.PERSONAL_INFO, "Could not submit", False)

    def _handle_custom_questions(self) -> None:
        """Handle common Greenhouse custom questions."""
        # Work authorization
        auth_selectors = [
            'select[name*="authorized"]',
            'select:has(option:has-text("authorized"))',
        ]
        self._select_option(auth_selectors, "Yes")

        # Sponsorship
        sponsor_selectors = [
            'select[name*="sponsorship"]',
            'select:has(option:has-text("sponsorship"))',
        ]
        self._select_option(sponsor_selectors, "No")

        # How did you hear about us
        source_selectors = [
            'select[name*="source"]',
            'select[name*="hear"]',
        ]
        self._select_option(source_selectors, "Job Board")

        # Check all visible checkboxes (consent, agreements)
        try:
            checkboxes = self._page.locator('input[type="checkbox"]:visible')
            for i in range(checkboxes.count()):
                cb = checkboxes.nth(i)
                if not cb.is_checked():
                    cb.check()
        except Exception:
            pass
```

## File: src/ats/handlers/icims.py

```python
"""iCIMS ATS handler."""
import logging

from ..base_handler import BaseATSHandler, FormPage, PageResult

logger = logging.getLogger(__name__)


class ICIMSHandler(BaseATSHandler):
    """Handler for iCIMS ATS applications."""

    ATS_NAME = "icims"

    APPLY_BUTTON_SELECTORS = [
        '#link-apply',
        'a:has-text("Apply")',
        'button:has-text("Apply")',
        '.iCIMS_ApplyButton',
    ]

    NEXT_BUTTON_SELECTORS = [
        '#next',
        'button:has-text("Next")',
        'button:has-text("Continue")',
        'input[type="submit"][value*="Next"]',
    ]

    SUBMIT_BUTTON_SELECTORS = [
        '#submit',
        'button:has-text("Submit")',
        'input[type="submit"][value*="Submit"]',
    ]

    FIELD_SELECTORS = {
        "first_name": [
            '#Contact_Information_firstname',
            'input[name*="firstname" i]',
        ],
        "last_name": [
            '#Contact_Information_lastname',
            'input[name*="lastname" i]',
        ],
        "email": [
            '#Contact_Information_email',
            'input[name*="email" i]',
            'input[type="email"]',
        ],
        "phone": [
            '#Contact_Information_phone',
            'input[name*="phone" i]',
            'input[type="tel"]',
        ],
        "city": [
            '#Contact_Information_city',
            'input[name*="city" i]',
        ],
        "resume": [
            'input[type="file"]',
            '#resumeUpload',
        ],
    }

    PAGE_INDICATORS = {
        FormPage.LOGIN: [
            'input[type="password"]',
            'text="Sign In"',
            '#login',
        ],
        FormPage.PERSONAL_INFO: [
            '#Contact_Information_email',
            'text="Contact Information"',
        ],
        FormPage.QUESTIONS: [
            'text="Position Specific Questions"',
            '[id*="Position_Specific"]',
        ],
        FormPage.REVIEW: [
            'text="Review"',
            'text="Summary"',
        ],
        FormPage.CONFIRMATION: [
            'text="Thank you"',
            'text="successfully"',
            'text="Application Submitted"',
        ],
    }

    def detect_page_type(self) -> FormPage:
        """Detect current iCIMS page type."""
        url = self._page.url.lower()
        
        # Check URL patterns first
        if "/login" in url:
            return FormPage.LOGIN
            
        for page_type, selectors in self.PAGE_INDICATORS.items():
            for selector in selectors:
                if self._is_visible(selector, timeout=500):
                    logger.info(f"iCIMS page type: {page_type.value}")
                    return page_type
        return FormPage.UNKNOWN

    def fill_current_page(self) -> PageResult:
        """Fill current iCIMS page."""
        page_type = self.detect_page_type()

        if page_type == FormPage.LOGIN:
            return PageResult(False, page_type, "Login required - cannot proceed", False)
        elif page_type == FormPage.PERSONAL_INFO:
            return self._handle_personal_info()
        elif page_type == FormPage.QUESTIONS:
            return self._handle_questions()
        elif page_type == FormPage.REVIEW:
            return self._handle_review()
        elif page_type == FormPage.CONFIRMATION:
            return PageResult(True, page_type, "Application submitted", False)
        else:
            return self._handle_unknown()

    def _handle_personal_info(self) -> PageResult:
        """Fill personal info page."""
        filled = 0

        if self._fill_field(self.FIELD_SELECTORS["first_name"], self._profile.get("first_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["last_name"], self._profile.get("last_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["email"], self._profile.get("email", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["phone"], self._profile.get("phone", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["city"], self._profile.get("city", "")):
            filled += 1

        if self._resume_path:
            self._upload_file(self.FIELD_SELECTORS["resume"], self._resume_path)

        if self.click_next():
            return PageResult(True, FormPage.PERSONAL_INFO, f"Filled {filled} fields", True)
        return PageResult(False, FormPage.PERSONAL_INFO, "Could not advance", False)

    def _handle_questions(self) -> PageResult:
        """Handle screening questions."""
        # Try to answer yes/no questions intelligently
        self._answer_work_auth_questions()
        self._check_all_consent_boxes()

        if self.click_next():
            return PageResult(True, FormPage.QUESTIONS, "Answered questions", True)
        return PageResult(False, FormPage.QUESTIONS, "Could not advance", False)

    def _handle_review(self) -> PageResult:
        """Submit application."""
        self._check_all_consent_boxes()
        
        if self.click_submit():
            self._wait(3000)
            return PageResult(True, FormPage.REVIEW, "Submitted", False)
        return PageResult(False, FormPage.REVIEW, "Could not submit", False)

    def _handle_unknown(self) -> PageResult:
        """Try to advance unknown page."""
        if self.click_next():
            return PageResult(True, FormPage.UNKNOWN, "Advanced", True)
        if self.click_submit():
            return PageResult(True, FormPage.UNKNOWN, "Submitted", False)
        return PageResult(False, FormPage.UNKNOWN, "Stuck", False)

    def _answer_work_auth_questions(self) -> None:
        """Answer common work authorization questions."""
        # Find radio buttons or dropdowns related to work auth
        work_auth = self._profile.get("extra", {}).get("work_authorization", True)
        needs_sponsor = self._profile.get("extra", {}).get("requires_sponsorship", False)

        # Work authorization - click Yes
        if work_auth:
            try:
                yes_buttons = self._page.locator('label:has-text("Yes")').all()
                for btn in yes_buttons[:2]:  # First couple yes options are usually auth related
                    btn.click()
            except Exception:
                pass

    def _check_all_consent_boxes(self) -> None:
        """Check all consent/agreement checkboxes."""
        try:
            checkboxes = self._page.locator('input[type="checkbox"]:visible').all()
            for cb in checkboxes:
                if not cb.is_checked():
                    cb.check()
        except Exception:
            pass
```

## File: src/ats/handlers/lever.py

```python
"""Lever ATS handler."""
import logging

from ..base_handler import BaseATSHandler, FormPage, PageResult

logger = logging.getLogger(__name__)


class LeverHandler(BaseATSHandler):
    """Handler for Lever ATS applications."""

    ATS_NAME = "lever"

    APPLY_BUTTON_SELECTORS = [
        'a.postings-btn:has-text("Apply")',
        'button:has-text("Apply for this job")',
        '.apply-button',
    ]

    NEXT_BUTTON_SELECTORS = [
        'button[type="submit"]',
        'button:has-text("Submit application")',
        'button:has-text("Submit")',
    ]

    SUBMIT_BUTTON_SELECTORS = NEXT_BUTTON_SELECTORS

    FIELD_SELECTORS = {
        "name": [
            'input[name="name"]',
            '#name',
        ],
        "email": [
            'input[name="email"]',
            '#email',
            'input[type="email"]',
        ],
        "phone": [
            'input[name="phone"]',
            '#phone',
            'input[type="tel"]',
        ],
        "resume": [
            'input[type="file"][name="resume"]',
            '.resume-upload input[type="file"]',
        ],
        "linkedin": [
            'input[name="urls[LinkedIn]"]',
            'input[placeholder*="LinkedIn"]',
        ],
        "github": [
            'input[name="urls[GitHub]"]',
            'input[placeholder*="GitHub"]',
        ],
        "portfolio": [
            'input[name="urls[Portfolio]"]',
            'input[name="urls[Other]"]',
        ],
        "current_company": [
            'input[name="org"]',
            '#current-company',
        ],
    }

    def detect_page_type(self) -> FormPage:
        """Detect current Lever page type."""
        if self._is_visible('text="Thank you"', timeout=500):
            return FormPage.CONFIRMATION
        if self._is_visible('.application-form', timeout=500):
            return FormPage.PERSONAL_INFO
        if self._is_visible('.postings-btn', timeout=500):
            return FormPage.JOB_LISTING
        return FormPage.UNKNOWN

    def fill_current_page(self) -> PageResult:
        """Fill Lever application."""
        page_type = self.detect_page_type()

        if page_type == FormPage.CONFIRMATION:
            return PageResult(True, page_type, "Application submitted", False)

        if page_type == FormPage.JOB_LISTING:
            if self.click_apply():
                self._wait(1500)
                page_type = FormPage.PERSONAL_INFO

        return self._fill_application_form()

    def _fill_application_form(self) -> PageResult:
        """Fill the Lever application form."""
        filled = 0

        # Lever uses combined name field
        full_name = f"{self._profile.get('first_name', '')} {self._profile.get('last_name', '')}".strip()
        if self._fill_field(self.FIELD_SELECTORS["name"], full_name):
            filled += 1

        if self._fill_field(self.FIELD_SELECTORS["email"], self._profile.get("email", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["phone"], self._profile.get("phone", "")):
            filled += 1

        # URLs
        self._fill_field(self.FIELD_SELECTORS["linkedin"], self._profile.get("linkedin_url", ""))
        self._fill_field(self.FIELD_SELECTORS["github"], self._profile.get("github_url", ""))
        self._fill_field(self.FIELD_SELECTORS["portfolio"], self._profile.get("portfolio_url", ""))
        self._fill_field(self.FIELD_SELECTORS["current_company"], self._profile.get("current_company", ""))

        # Resume
        if self._resume_path:
            self._upload_file(self.FIELD_SELECTORS["resume"], self._resume_path)
            self._wait(1500)

        # Handle custom questions
        self._handle_custom_questions()

        # Submit
        if self.click_submit():
            self._wait(3000)
            if self.detect_page_type() == FormPage.CONFIRMATION:
                return PageResult(True, FormPage.PERSONAL_INFO, "Application submitted", False)
            return PageResult(True, FormPage.PERSONAL_INFO, f"Filled {filled} fields", True)

        return PageResult(False, FormPage.PERSONAL_INFO, "Could not submit", False)

    def _handle_custom_questions(self) -> None:
        """Handle Lever custom questions."""
        # Check all checkboxes
        try:
            checkboxes = self._page.locator('input[type="checkbox"]:visible').all()
            for cb in checkboxes:
                if not cb.is_checked():
                    cb.check()
        except Exception:
            pass

        # Answer common dropdown questions
        self._select_option(['select[name*="authorized"]'], "Yes")
        self._select_option(['select[name*="sponsor"]'], "No")
```

## File: src/ats/handlers/phenom.py

```python
"""Phenom ATS handler (used by companies like GitHub, etc.)."""
import logging

from ..base_handler import BaseATSHandler, FormPage, PageResult

logger = logging.getLogger(__name__)


class PhenomHandler(BaseATSHandler):
    """Handler for Phenom ATS applications."""

    ATS_NAME = "phenom"

    APPLY_BUTTON_SELECTORS = [
        '#link-apply',
        '[data-ph-at-id="apply-link"]',
        'a:has-text("Apply")',
        'button:has-text("Apply")',
    ]

    NEXT_BUTTON_SELECTORS = [
        '#next',
        '[data-ph-at-id="next-button"]',
        'button:has-text("Next")',
        'button:has-text("Continue")',
    ]

    SUBMIT_BUTTON_SELECTORS = [
        '#submit',
        '[data-ph-at-id="submit-button"]',
        'button:has-text("Submit")',
    ]

    FIELD_SELECTORS = {
        "email": ['#email', 'input[name="email"]', 'input[type="email"]'],
        "first_name": ['#firstName', 'input[name="firstName"]'],
        "last_name": ['#lastName', 'input[name="lastName"]'],
        "phone": ['#phone', 'input[name="phone"]', 'input[type="tel"]'],
        "city": ['#city', 'input[name="city"]'],
        "resume": ['input[type="file"]'],
    }

    def detect_page_type(self) -> FormPage:
        """Detect current Phenom page type."""
        url = self._page.url.lower()
        
        if "/confirmation" in url or self._is_visible('text="Thank you"'):
            return FormPage.CONFIRMATION
        if "/login" in url or self._is_visible('input[type="password"]'):
            return FormPage.LOGIN
        if self._is_visible('#link-apply'):
            return FormPage.JOB_LISTING
        if self._is_visible('form'):
            return FormPage.PERSONAL_INFO
        return FormPage.UNKNOWN

    def fill_current_page(self) -> PageResult:
        """Fill current Phenom page."""
        page_type = self.detect_page_type()

        if page_type == FormPage.CONFIRMATION:
            return PageResult(True, page_type, "Application submitted", False)
        if page_type == FormPage.LOGIN:
            return PageResult(False, page_type, "Login required", False)
        if page_type == FormPage.JOB_LISTING:
            if self.click_apply():
                self._wait(2000)
                return PageResult(True, page_type, "Clicked Apply", True)
            return PageResult(False, page_type, "No Apply button", False)

        return self._fill_form()

    def _fill_form(self) -> PageResult:
        """Fill Phenom application form."""
        filled = 0

        if self._fill_field(self.FIELD_SELECTORS["email"], self._profile.get("email", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["first_name"], self._profile.get("first_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["last_name"], self._profile.get("last_name", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["phone"], self._profile.get("phone", "")):
            filled += 1
        if self._fill_field(self.FIELD_SELECTORS["city"], self._profile.get("city", "")):
            filled += 1

        if self._resume_path:
            self._upload_file(self.FIELD_SELECTORS["resume"], self._resume_path)

        # Check any consent boxes
        self._check_all_checkboxes()

        # Try next, then submit
        if self.click_next():
            return PageResult(True, FormPage.PERSONAL_INFO, f"Filled {filled}, advanced", True)
        if self.click_submit():
            self._wait(3000)
            return PageResult(True, FormPage.PERSONAL_INFO, "Submitted", False)

        return PageResult(False, FormPage.PERSONAL_INFO, "Could not advance", False)

    def _check_all_checkboxes(self) -> None:
        """Check all visible checkboxes."""
        try:
            for cb in self._page.locator('input[type="checkbox"]:visible').all():
                if not cb.is_checked():
                    cb.check()
        except Exception:
            pass
```

## File: src/ats/handlers/__init__.py

```python
"""ATS handlers."""
from .workday import WorkdayHandler
from .greenhouse import GreenhouseHandler
from .lever import LeverHandler
from .icims import ICIMSHandler
from .phenom import PhenomHandler

__all__ = [
    "WorkdayHandler",
    "GreenhouseHandler",
    "LeverHandler",
    "ICIMSHandler",
    "PhenomHandler",
]
```

## File: src/ats/registry.py

```python
"""Registry of ATS handlers."""
import logging
from typing import Optional, Type

from playwright.sync_api import Page

from .detector import ATSType, ATSDetector
from .base_handler import BaseATSHandler
from .handlers import (
    WorkdayHandler,
    GreenhouseHandler,
    LeverHandler,
    ICIMSHandler,
    PhenomHandler,
)

logger = logging.getLogger(__name__)


HANDLER_REGISTRY: dict[ATSType, Type[BaseATSHandler]] = {
    ATSType.WORKDAY: WorkdayHandler,
    ATSType.GREENHOUSE: GreenhouseHandler,
    ATSType.LEVER: LeverHandler,
    ATSType.ICIMS: ICIMSHandler,
    ATSType.PHENOM: PhenomHandler,
}


def get_handler(
    page: Page,
    profile: dict,
    resume_path: Optional[str] = None,
) -> Optional[BaseATSHandler]:
    """Get the appropriate handler for the current page."""
    detector = ATSDetector(page)
    ats_type = detector.detect()

    if ats_type == ATSType.UNKNOWN:
        logger.info("No ATS handler available - will use Claude fallback")
        return None

    handler_class = HANDLER_REGISTRY.get(ats_type)
    if handler_class:
        logger.info(f"Using {ats_type.value} handler")
        return handler_class(page, profile, resume_path)

    return None
```

## File: src/ats/__init__.py

```python
"""ATS detection and handling system."""
from .detector import ATSType, ATSDetector
from .registry import get_handler
from .base_handler import BaseATSHandler, FormPage, PageResult

__all__ = [
    "ATSType",
    "ATSDetector",
    "get_handler",
    "BaseATSHandler",
    "FormPage",
    "PageResult",
]
```

## File: src/ats/fallback.py

```python
"""Claude fallback for unknown ATS systems."""
import logging
from typing import Optional

from playwright.sync_api import Page

from .base_handler import FormPage, PageResult

logger = logging.getLogger(__name__)


class ClaudeFallback:
    """Fallback to Claude for unknown ATS systems."""

    def __init__(
        self,
        page: Page,
        claude_agent,  # ClaudeAgent instance
        profile: dict,
        resume_path: Optional[str] = None,
    ) -> None:
        self._page = page
        self._claude = claude_agent
        self._profile = profile
        self._resume_path = resume_path

    def fill_current_page(self, dom_service) -> PageResult:
        """Use Claude to fill the current page."""
        # This delegates to the existing Claude-based approach
        # but only as a last resort
        logger.info("Using Claude fallback for unknown ATS")
        
        dom_state = dom_service.extract()
        plan = self._claude.analyze_form(dom_state, self._profile, dom_service)
        
        if not plan:
            return PageResult(False, FormPage.UNKNOWN, "Claude could not analyze page", False)

        if plan.page_type == "confirmation":
            return PageResult(True, FormPage.CONFIRMATION, "Confirmation detected", False)

        # Execute plan... (this would use the existing runner)
        return PageResult(True, FormPage.UNKNOWN, f"Claude returned {len(plan.actions)} actions", True)
```

## Integration: Update src/agent/form_processor.py

Add ATS handler integration at the start of the process() method. The handler tries first, Claude fallback only if handler returns None or fails:

```python
from ..ats import get_handler, ATSType

def process(self, job_url: str, source: Optional[JobSource] = None) -> ApplicationResult:
    """Process multi-page application form."""
    self._indeed_helpers.reset()
    self._success_detector.reset()

    # Try ATS-specific handler first
    handler = get_handler(self._page.raw, self._profile, self._resume_path)
    
    if handler:
        return self._process_with_handler(handler, job_url)
    
    # Fall back to Claude-based approach
    logger.info("No ATS handler - using Claude fallback")
    return self._process_with_claude(job_url, source)

def _process_with_handler(self, handler, job_url: str) -> ApplicationResult:
    """Process application using ATS-specific handler."""
    max_pages = 15
    pages = 0
    
    while pages < max_pages:
        pages += 1
        logger.info(f"=== Handler Page {pages} === URL: {self._page.url}")
        
        result = handler.fill_current_page()
        logger.info(f"Handler result: {result.message}")
        
        if not result.success:
            return ApplicationResult(
                ApplicationStatus.FAILED,
                result.message,
                pages,
                job_url
            )
        
        if not result.needs_next_page:
            # Check if it's confirmation
            if result.page_type == FormPage.CONFIRMATION:
                return ApplicationResult(
                    ApplicationStatus.SUCCESS,
                    "Application submitted via ATS handler",
                    pages,
                    job_url
                )
            return ApplicationResult(
                ApplicationStatus.FAILED,
                result.message,
                pages,
                job_url
            )
        
        self._page.wait(2000)
    
    return ApplicationResult(
        ApplicationStatus.MAX_PAGES_REACHED,
        f"Handler reached {max_pages} pages",
        pages,
        job_url
    )

def _process_with_claude(self, job_url: str, source: Optional[JobSource] = None) -> ApplicationResult:
    """Original Claude-based processing - now a fallback."""
    # Move existing process() logic here
    ...
```

## Code standards
- Static typing everywhere
- Max 25 lines per function where possible (split into helpers)
- Use logging module
- Each handler file should be self-contained
- Don't break existing functionality - ATS handlers are tried first, Claude is fallback

Write clean, scalable, modular, efficient code. Follow single responsibility principle. Do not repeat yourself. Use consistent naming conventions. No unnecessary comments.