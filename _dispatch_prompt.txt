## Spec: Fix Indeed Selectors - REAL SELECTORS FROM LIVE DOM [CRITICAL]

### Context
User provided actual DOM from live Indeed SmartApply pages.

### REAL Indeed SmartApply Selectors

**Continue Button:**
```html
<button type="button" data-testid="continue-button" aria-busy="false" class="mosaic-provider-module-apply-resume-selection-6ja1uy e8ju0x50"><span>Continue</span></button>
```
Selector: `[data-testid="continue-button"]`

**Submit Button (Review Page):**
```html
<button role="button" type="submit" name="submit-application" data-testid="submit-application-button" class="mosaic-provider-module-apply-preview-6ja1uy e8ju0x50"><span>Submit your application</span></button>
```
Selectors:
- `[data-testid="submit-application-button"]`
- `button[name="submit-application"]`
- `button[type="submit"]`

### Fix `src/agent/indeed_form_filler.py`

Replace CONTINUE_PATTERNS with these REAL selectors:

```python
CONTINUE_PATTERNS: list[str] = [
    # REAL selectors from live Indeed DOM - Jan 2026
    '[data-testid="submit-application-button"]',  # Final submit on review page
    'button[name="submit-application"]',           # Alternative submit selector
    '[data-testid="continue-button"]',             # Continue button on form pages
    
    # Fallbacks
    'button[type="submit"]',
    'button:has-text("Submit your application")',
    'button:has-text("Continue")',
]
```

### Also Fix `src/agent/answer_engine.py` Pattern Order

The disability question matched `personal.website` because patterns run in order.

Move EEO patterns (disability, gender, race, veteran) to the TOP of the pattern list so they match BEFORE personal info patterns.

Current order causes "Voluntary Self-Identification of Disability" to match the loose `r"website|portfolio|github"` pattern before the disability pattern can run.

### Test
Run: `pytest tests/ -x -q`

### Code Standards
- Static typing everywhere
- Guard clauses
- logging module only

## Code Standards

Write code that looks inevitable. Follow these constraints:

**Restraint**
- Solve it in one file if possible
- No abstractions until the third time you need them
- No classes if functions will do
- No inheritance - use composition

**Functions**
- Max 25 lines, aim for 15
- One level of nesting max
- Name describes exactly what it does: `extract_billable_hours()` not `process_data()`
- Input → transform → output. No side effects unless that's the point.

**Files**
- Max 200 lines for new files
- One clear responsibility
- If you're adding a second "system" to a file, stop and split

**No Ceremony**
- No AbstractFactory, no IServiceProvider, no Manager classes
- No code "just in case" - solve the actual problem
- Delete commented-out code, don't keep it

**Data**
- Use dataclasses or plain dicts, not classes with only __init__ and getters
- Data flows obviously - reader should predict what happens next
- No global state

The best code is code you delete. Every line is a liability.
