Fix LinkedIn Easy Apply flow getting stuck immediately - missing logging and broken stuck detection.

## PROBLEM

The logs show:
```
19:34:07 - Using deterministic form filler for Easy Apply
19:34:19 - Stuck on same page 2 times, aborting
```

NO form filler logs in between (no "Filled", "Selected", "Radio", etc.). This means either:
1. The modal isn't being found but silently failing
2. `_get_modal_hash()` returns "" twice → thinks stuck immediately
3. Exceptions being swallowed

## ROOT CAUSE

In `_get_modal_hash()`:
- If progress bar not found AND input count fails → returns ""
- First iteration: last_page_hash = "", current_hash = "" → stuck_count = 1
- Second iteration: both still "" → stuck_count = 2 → breaks immediately

## FILES TO FIX

### src/agent/linkedin_flow.py

**Fix 1: Add comprehensive logging to `_process_easy_apply()`:**

```python
def _process_easy_apply(self, job_url: str) -> ApplicationResult:
    """Process LinkedIn Easy Apply using deterministic form filler."""
    logger.info("Using deterministic form filler for Easy Apply")

    answer_engine = AnswerEngine()
    filler = LinkedInFormFiller(self._page.raw, answer_engine)
    
    last_page_hash = ""
    stuck_count = 0
    max_stuck = 3  # Increase from 2 to 3 for more tolerance

    for page_num in range(self._max_pages):
        logger.info(f"Processing page {page_num + 1}/{self._max_pages}")
        self._page.wait(1000)

        if filler.is_confirmation_page():
            logger.info("Confirmation page detected - application submitted!")
            filler.close_modal()
            return ApplicationResult(
                status=ApplicationStatus.SUCCESS,
                message="Application submitted",
                pages_processed=page_num + 1,
                url=job_url,
            )

        # Get current page hash to detect stuck
        current_hash = self._get_modal_hash()
        logger.debug(f"Page hash: '{current_hash}' (last: '{last_page_hash}')")
        
        # Only count as stuck if we have a valid hash
        if current_hash and current_hash == last_page_hash:
            stuck_count += 1
            logger.warning(f"Same page hash detected ({stuck_count}/{max_stuck})")
            if stuck_count >= max_stuck:
                logger.warning(f"Stuck on same page {stuck_count} times, aborting")
                break
        else:
            stuck_count = 0
            last_page_hash = current_hash

        # Fill the form
        modal_found = filler.fill_current_modal()
        logger.info(f"Page {page_num + 1}: Modal found={modal_found}")

        # Click next button
        if not filler.click_next():
            logger.warning(f"Page {page_num + 1}: Could not find next button")
            # Don't break immediately - try waiting and retrying once
            self._page.wait(1000)
            if not filler.click_next():
                logger.warning("Next button still not found after retry, aborting")
                break

        self._page.wait(1000)

    return ApplicationResult(
        status=ApplicationStatus.FAILED,
        message="Max pages reached or stuck",
        pages_processed=page_num + 1,
        url=job_url,
    )
```

**Fix 2: Make `_get_modal_hash()` more robust:**

```python
def _get_modal_hash(self) -> str:
    """Get a hash of the current modal state to detect if we're stuck."""
    hash_parts = []
    
    # Try progress bar percentage
    try:
        progress = self._page.raw.locator("progress").first
        if progress.is_visible(timeout=500):
            value = progress.get_attribute("value") or ""
            max_val = progress.get_attribute("max") or "100"
            if value:
                hash_parts.append(f"progress:{value}/{max_val}")
    except Exception:
        pass
    
    # Try aria-valuenow on progress (LinkedIn uses this)
    try:
        progress_aria = self._page.raw.locator("[role='progressbar']").first
        if progress_aria.is_visible(timeout=500):
            value = progress_aria.get_attribute("aria-valuenow") or ""
            if value:
                hash_parts.append(f"aria-progress:{value}")
    except Exception:
        pass
    
    # Count form elements in modal
    try:
        modal_selectors = [
            ".jobs-easy-apply-modal",
            "[data-test-modal]",
            ".artdeco-modal",
            "[role='dialog']",
        ]
        for modal_sel in modal_selectors:
            try:
                modal = self._page.raw.locator(modal_sel).first
                if modal.is_visible(timeout=300):
                    inputs = modal.locator("input:visible").count()
                    selects = modal.locator("select:visible").count()
                    textareas = modal.locator("textarea:visible").count()
                    fieldsets = modal.locator("fieldset:visible").count()
                    hash_parts.append(f"form:{inputs}i/{selects}s/{textareas}t/{fieldsets}f")
                    break
            except Exception:
                continue
    except Exception:
        pass
    
    # Get visible question text as part of hash
    try:
        labels = self._page.raw.locator(".jobs-easy-apply-modal .fb-form-element-label").all()
        label_texts = []
        for label in labels[:3]:  # First 3 labels
            try:
                text = label.text_content()
                if text:
                    label_texts.append(text[:20])  # First 20 chars
            except Exception:
                pass
        if label_texts:
            hash_parts.append(f"labels:{','.join(label_texts)}")
    except Exception:
        pass
    
    result = "|".join(hash_parts) if hash_parts else "empty"
    logger.debug(f"Modal hash components: {result}")
    return result
```

### src/agent/linkedin_form_filler.py

**Fix 3: Add logging at start of `fill_current_modal()`:**

```python
def fill_current_modal(self) -> bool:
    """Fill all fields in the current Easy Apply modal.

    Returns:
        True if modal was found and processed, False if no modal.
    """
    # Try multiple modal selectors
    modal_selectors = [
        '.jobs-easy-apply-modal',
        '[data-test-modal]',
        '.artdeco-modal',
        '[role="dialog"]',
    ]
    
    modal = None
    for selector in modal_selectors:
        try:
            candidate = self._page.locator(selector).first
            if candidate.is_visible(timeout=1000):
                modal = candidate
                logger.info(f"Found modal with selector: {selector}")
                break
        except Exception:
            continue
    
    if modal is None:
        logger.warning("No Easy Apply modal found with any selector")
        return False

    # Count fields before filling
    try:
        input_count = modal.locator("input:visible").count()
        select_count = modal.locator("select:visible").count()
        fieldset_count = modal.locator("fieldset:visible").count()
        logger.info(f"Modal has {input_count} inputs, {select_count} selects, {fieldset_count} fieldsets")
    except Exception as e:
        logger.debug(f"Could not count fields: {e}")

    self._fill_text_inputs(modal)
    self._fill_selects(modal)
    self._fill_radios(modal)
    self._fill_skill_checkboxes(modal)
    self._fill_checkboxes(modal)
    self._fill_textareas(modal)
    self._uncheck_follow_company()

    return True
```

**Fix 4: Add logging to `click_next()` to show what's happening:**

```python
def click_next(self) -> bool:
    """Click the next/submit/review button."""
    for selector in self.SUBMIT_BUTTON_PATTERNS:
        try:
            btn = self._page.locator(selector).first
            if btn.is_visible(timeout=1000):
                btn_text = btn.text_content() or btn.get_attribute("aria-label") or selector
                btn.click()
                logger.info(f"Clicked button: {btn_text[:30]}")
                self._page.wait_for_timeout(500)
                return True
        except Exception as e:
            logger.debug(f"Button selector {selector} failed: {e}")
            continue
    
    logger.warning("No next/submit button found with any selector")
    return False
```

## SUMMARY

1. **_process_easy_apply**: Added logging for each page, increased stuck threshold to 3, only count stuck if hash is non-empty, retry click_next once before aborting

2. **_get_modal_hash**: Made more robust - tries progress bar, aria-valuenow, multiple modal selectors, form element counts, and label text. Returns "empty" instead of "" so we can distinguish no hash from empty string

3. **fill_current_modal**: Try multiple modal selectors, log which one worked, count fields before filling

4. **click_next**: Log which button was clicked or why it failed

Run again and we'll see EXACTLY what's happening on each page.

## Code Standards

Write code that looks inevitable. Follow these constraints:

**Restraint**
- Solve it in one file if possible
- No abstractions until the third time you need them
- No classes if functions will do
- No inheritance - use composition

**Functions**
- Max 25 lines, aim for 15
- One level of nesting max
- Name describes exactly what it does: `extract_billable_hours()` not `process_data()`
- Input → transform → output. No side effects unless that's the point.

**Files**
- Max 200 lines for new files
- One clear responsibility
- If you're adding a second "system" to a file, stop and split

**No Ceremony**
- No AbstractFactory, no IServiceProvider, no Manager classes
- No code "just in case" - solve the actual problem
- Delete commented-out code, don't keep it

**Data**
- Use dataclasses or plain dicts, not classes with only __init__ and getters
- Data flows obviously - reader should predict what happens next
- No global state

The best code is code you delete. Every line is a liability.
