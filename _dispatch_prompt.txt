# Spec-Driven Implementation

## CRITICAL: TRUST THE SPEC

The specification below is COMPLETE. Do not:
- Read README, ARCHITECTURE, or documentation files
- Search for patterns or conventions in the codebase
- Explore directory structures
- Read files unrelated to your implementation

Only read files that:
1. You need to import from (check the target path's neighbors)
2. Contain types/classes referenced in the interface

The spec tells you exactly what to build. Trust it.

## CIRCUIT BREAKER

If you have made 8+ file reads without writing any code, STOP.
You are exploring instead of implementing. The spec is complete.
Write the implementation now with what you know.

## THE SPECIFICATION

# Specification: ConfigSuggester
Tier: FEATURE

## Description
Takes summarized failures and generates structured fix instructions that can be dispatched to Claude Code.

## Interface
- `FixSuggestion` dataclass with: target_file, fix_type, description, suggested_content, failure_count
- `ConfigSuggester.suggest(summaries: list[FailureSummary]) -> list[FixSuggestion]` — Generate fix suggestions from failure summaries

## Must Do
- Map failure types to fix strategies:
- `unknown_question` → fix_type="add_pattern", target_file="src/agent/answer_engine.py", generate regex pattern + config key mapping
- `react_select_fail` → fix_type="add_handler", target_file="src/agent/form_processor.py", generate selector pattern for react-select handling
- `validation_error` → fix_type="investigate", target_file="src/agent/form_processor.py", include field selector and error messages for manual review
- `stuck_loop` → fix_type="no_action", description="Handled by stuck detection" (no suggestion needed)
- `timeout` → fix_type="investigate", include page_url and last_action
- `crash` → fix_type="investigate", include exception info
- For unknown_question: generate regex pattern from canonical question text (escape special chars, replace numbers with \d+, etc.)
- Sort suggestions by failure_count descending (fix highest impact first)
- Include example details in suggested_content for context

## Must Not Do
- Don't read/write files - just generate suggestion objects
- Don't import FailureSummarizer (receive FailureSummary objects, define import at type-check time only)

## Edge Cases
- Empty summaries list → return empty list
- Summary with count=0 → skip
- stuck_loop type → return empty suggestion (already handled)
- Question text with special regex chars → escape properly

## Validation
- Tests: pytest tests/feedback/test_config_suggester.py -v

## Target Path
src/feedback/config_suggester.py

## YOUR TASK

**Tier: FEATURE** - Standard feature implementation.
- Full behavior test coverage
- All edge cases must be tested
- Contract tests for public interfaces

### Step 1: Implement the Interface

Implementation location: `src/feedback/config_suggester.py`

Implementation Rules:
1. Follow interface signatures EXACTLY as specified
2. Handle all edge cases as specified
3. Ensure preconditions are checked
4. Ensure postconditions are satisfied
5. Respect all 'Must Not Do' constraints

### Step 2: Write Tests

Test file location: `tests/test_configsuggester.py`

After implementing, write tests that verify contract and behavior:

**Must Do Tests:**
- Write one test for each item in the 'Must Do' section
- Tests should verify the behavior/contract, not implementation details

**Edge Case Tests:**
- Write one test for each edge case specified

Test Code Requirements:
- Use pytest fixtures for shared setup
- Include full type hints
- Use descriptive test names
- Keep tests focused and independent

### Step 3: Validate

Run validation: `pytest tests/feedback/test_config_suggester.py -v`

Iterate until all tests pass.
Maximum iterations: 5

Write clean, scalable, modular, efficient code. Follow single responsibility principle. Do not repeat yourself. Use consistent naming conventions. No unnecessary comments.