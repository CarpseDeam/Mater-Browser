# Spec-Driven Implementation

## CRITICAL: TRUST THE SPEC

The specification below is COMPLETE. Do not:
- Read README, ARCHITECTURE, or documentation files
- Search for patterns or conventions in the codebase
- Explore directory structures
- Read files unrelated to your implementation

Only read files that:
1. You need to import from (check the target path's neighbors)
2. Contain types/classes referenced in the interface

The spec tells you exactly what to build. Trust it.

## CIRCUIT BREAKER

If you have made 8+ file reads without writing any code, STOP.
You are exploring instead of implementing. The spec is complete.
Write the implementation now with what you know.

## THE SPECIFICATION

# Specification: P1ThreadSafety
Tier: HOTFIX

## Description
Add thread safety to AutoRepairer to prevent race conditions.

## Interface
- `AutoRepairer.__init__()` - Add `self._counter_lock = threading.Lock()`
- `AutoRepairer.record_failure()` - Use lock when incrementing counter
- `AutoRepairer.maybe_repair()` - Use lock when checking/resetting counter

## Must Do
- Add `self._counter_lock = threading.Lock()` in `__init__` (note: there's already a `_lock` used by FailureLogger, name this one `_counter_lock`)
- Wrap `self._failure_count += 1` in `record_failure()` with the lock
- Wrap the threshold check and counter reset in `maybe_repair()` with the lock
- Use context manager pattern: `with self._counter_lock:`

## Must Not Do
- Hold lock during HTTP request (that would block other threads)
- Change any other logic
- Rename or remove existing attributes

## Validation
- Tests: pytest tests/feedback/test_auto_repairer.py -v

## Target Path
src/feedback/auto_repairer.py

## YOUR TASK

**Tier: HOTFIX** - Minimal scope, fast iteration.
- Focus on the specific bug/issue only
- 1-3 targeted tests maximum

### Step 1: Implement the Interface

Implementation location: `src/feedback/auto_repairer.py`

Implementation Rules:
1. Follow interface signatures EXACTLY as specified
2. Handle all edge cases as specified
3. Ensure preconditions are checked
4. Ensure postconditions are satisfied
5. Respect all 'Must Not Do' constraints

**Handling Conflicts:**
If a 'Must Not Do' constraint conflicts with a 'Must Do' requirement (e.g., fixing behavior breaks existing tests but you're told not to modify tests), prioritize the 'Must Do'. Note the conflict and make the minimal change needed.

### Step 2: Write Tests

Test file location: `tests/test_p1threadsafety.py`

After implementing, write tests that verify contract and behavior:

**Must Do Tests:**
- Write one test for each item in the 'Must Do' section
- Tests should verify the behavior/contract, not implementation details

Test Code Requirements:
- Use pytest fixtures for shared setup
- Include full type hints
- Use descriptive test names
- Keep tests focused and independent

### Step 3: Validate

Run validation: `pytest tests/feedback/test_auto_repairer.py -v`

Iterate until all tests pass.
Maximum iterations: 5

Write clean, scalable, modular, efficient code. Follow single responsibility principle. Do not repeat yourself. Use consistent naming conventions. No unnecessary comments.