## Spec: Fix Indeed and LinkedIn Selectors - RESEARCHED REAL SELECTORS [CRITICAL]

### Context
Previous tasks were guessing. I researched the actual selectors from working automation bots.

### LinkedIn Easy Apply Selectors (FROM WORKING BOTS)

These are from https://github.com/nicolomantini/LinkedIn-Easy-Apply-Bot which is actively maintained:

```python
# Easy Apply button
'button[contains(@class, "jobs-apply-button")]'
'.jobs-apply-button--top-card'

# Submit/Next/Review buttons
'button[aria-label="Submit application"]'  # FINAL SUBMIT
'.artdeco-button--primary'  # Generic primary button (Next, Review, Submit)

# Form fields
'.jobs-easy-apply-form-section__grouping'  # Field containers
'.artdeco-text-input--input'  # Text inputs

# Resume upload  
'//*[contains(@id, "jobs-document-upload-file-input-upload-resume")]'

# Error message
'.artdeco-inline-feedback__message'

# Modal
'.jobs-easy-apply-modal'
```

### Indeed Easy Apply - NEED TO INSPECT DOM

The bot is landing on `smartapply.indeed.com/.../review-module` but can't find the submit button.

**TASK: Run the bot, capture what's on the review page, and find the actual selectors.**

Use this approach:
1. Look at `src/agent/indeed_form_filler.py` current selectors
2. Add debug logging to dump the page HTML when on review-module URL
3. OR just add more aggressive selectors based on common patterns:

```python
# Indeed patterns to TRY (need validation):
'button[data-testid*="submit"]'
'button:has-text("Submit your application")'
'button:has-text("Submit application")' 
'button[type="submit"]'
'.ia-continueButton'
'[data-tn-element="submit"]'
'button.ia-Button'
'button.css-1c7gy80'  # Indeed uses CSS modules - inspect actual classes
```

### Fix `src/agent/indeed_form_filler.py`

Update CONTINUE_PATTERNS to include submit-specific selectors at the TOP:

```python
CONTINUE_PATTERNS = [
    # Submit buttons (for review/final page) - CHECK THESE FIRST
    'button[data-testid*="submit"]',
    'button:has-text("Submit your application")',
    'button:has-text("Submit application")',
    
    # Continue buttons  
    '[data-testid="ia-continueButton"]',
    'button:has-text("Continue")',
    'button:has-text("Apply")',
    'button:has-text("Review")',
    'button[type="submit"]',
    '.ia-continueButton',
]
```

### Fix `src/agent/linkedin_form_filler.py`

Update SUBMIT_BUTTON_PATTERNS with the researched selectors:

```python
SUBMIT_BUTTON_PATTERNS = [
    # Final submit (MOST SPECIFIC FIRST)
    'button[aria-label="Submit application"]',
    
    # Next/Continue/Review  
    'button[aria-label*="Submit" i]',
    'button[aria-label*="Review" i]',
    'button[aria-label*="Next" i]',
    '.artdeco-button--primary',
    'button:has-text("Submit application")',
    'button:has-text("Review")',
    'button:has-text("Next")',
    'button:has-text("Continue")',
    'button[type="submit"]',
]
```

### Fix Pattern Order in `src/agent/answer_engine.py`

Move EEO patterns to TOP so they match before personal info patterns that are too loose.

The disability question matched "personal.website" because `r"website|portfolio|github"` pattern matched before the disability pattern could run.

### Test
Run: `pytest tests/ -x -q`

### Code Standards
- Static typing everywhere  
- Guard clauses
- logging module only

## Code Standards

Write code that looks inevitable. Follow these constraints:

**Restraint**
- Solve it in one file if possible
- No abstractions until the third time you need them
- No classes if functions will do
- No inheritance - use composition

**Functions**
- Max 25 lines, aim for 15
- One level of nesting max
- Name describes exactly what it does: `extract_billable_hours()` not `process_data()`
- Input → transform → output. No side effects unless that's the point.

**Files**
- Max 200 lines for new files
- One clear responsibility
- If you're adding a second "system" to a file, stop and split

**No Ceremony**
- No AbstractFactory, no IServiceProvider, no Manager classes
- No code "just in case" - solve the actual problem
- Delete commented-out code, don't keep it

**Data**
- Use dataclasses or plain dicts, not classes with only __init__ and getters
- Data flows obviously - reader should predict what happens next
- No global state

The best code is code you delete. Every line is a liability.
