# Spec-Driven Implementation

## CRITICAL: TRUST THE SPEC

The specification below is COMPLETE. Do not:
- Read README, ARCHITECTURE, or documentation files
- Search for patterns or conventions in the codebase
- Explore directory structures
- Read files unrelated to your implementation

Only read files that:
1. You need to import from (check the target path's neighbors)
2. Contain types/classes referenced in the interface

The spec tells you exactly what to build. Trust it.

## CIRCUIT BREAKER

If you have made 8+ file reads without writing any code, STOP.
You are exploring instead of implementing. The spec is complete.
Write the implementation now with what you know.

## THE SPECIFICATION

# Specification: AutoRepairIntegration
Tier: FEATURE

## Description
Add self-healing capability to the automation runner. When failures accumulate, automatically dispatch fixes to Claude Code without manual intervention.

## Interface
- `AutoRepairer.__init__(threshold: int = 5, cooldown_minutes: int = 10)` — Configure when to trigger repairs
- `AutoRepairer.record_failure(failure: ApplicationFailure) -> None` — Track a failure
- `AutoRepairer.maybe_repair() -> bool` — Check threshold, dispatch fix if needed, return True if dispatched
- `AutoRepairer.reset() -> None` — Clear failure count after successful repair

## Must Do
- Track failure count since last repair
- Trigger repair when count >= threshold
- Cooldown period prevents spam (don't repair more than once per cooldown_minutes)
- Use same logic as `--auto-fix` CLI: read failures, summarize, suggest, POST to bridge
- POST to `http://localhost:5001/dispatch` with generated spec
- Log when repair is triggered and result
- Handle bridge connection errors gracefully (log warning, continue running)
- Run asynchronously - don't block the main automation loop

## Must Not Do
- Don't block automation while repair runs
- Don't crash if bridge unavailable
- Don't repair on every single failure (respect threshold + cooldown)

## Edge Cases
- Bridge server not running → log warning, skip repair, continue automation
- No unaddressed failures → skip repair
- All failures same type → still generate single fix spec
- Repair dispatched but fails → log error, reset cooldown anyway (prevent spam)

## Validation
- Tests: pytest tests/feedback/test_auto_repairer.py -v

## Target Path
src/feedback/auto_repairer.py (new)

## YOUR TASK

**Tier: FEATURE** - Standard feature implementation.
- Full behavior test coverage
- All edge cases must be tested
- Contract tests for public interfaces

### Step 1: Implement the Interface

Implementation location: `src/feedback/auto_repairer.py (new)`

Implementation Rules:
1. Follow interface signatures EXACTLY as specified
2. Handle all edge cases as specified
3. Ensure preconditions are checked
4. Ensure postconditions are satisfied
5. Respect all 'Must Not Do' constraints

### Step 2: Write Tests

Test file location: `tests/test_autorepairintegration.py`

After implementing, write tests that verify contract and behavior:

**Must Do Tests:**
- Write one test for each item in the 'Must Do' section
- Tests should verify the behavior/contract, not implementation details

**Edge Case Tests:**
- Write one test for each edge case specified

Test Code Requirements:
- Use pytest fixtures for shared setup
- Include full type hints
- Use descriptive test names
- Keep tests focused and independent

### Step 3: Validate

Run validation: `pytest tests/feedback/test_auto_repairer.py -v`

Iterate until all tests pass.
Maximum iterations: 5

Write clean, scalable, modular, efficient code. Follow single responsibility principle. Do not repeat yourself. Use consistent naming conventions. No unnecessary comments.