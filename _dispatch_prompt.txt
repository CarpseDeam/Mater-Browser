TASK: Fix radio and checkbox fallback handling in LinkedIn form filler

Files to edit:
- C:\Projects\Mater-Browser\src\agent\linkedin_form_filler.py
- C:\Projects\Mater-Browser\src\agent\answer_engine.py

ISSUE: Bot loops forever because required radio/checkbox fields stay empty when no answer is configured.

FIX 1 - linkedin_form_filler.py `_fill_single_radio_group()`:
When answer is None, select the FIRST radio option instead of skipping:

```python
if answer is None:
    # Fallback: select first option for required radio groups
    try:
        radios = fieldset.locator(LinkedInSelectors.RADIO).all()
        if radios:
            first_radio = radios[0]
            if not first_radio.is_checked():
                first_radio.check()
            label = self._get_radio_label(first_radio)
            logger.info(f"Fallback radio (first option): {question[:50]} = {label}")
    except Exception as e:
        logger.warning(f"Fallback radio failed: {e}")
    return True
```

FIX 2 - linkedin_form_filler.py `_fill_checkboxes()`:
When answer is None, check the box UNLESS it contains spam keywords:

```python
if answer is None:
    q_lower = question.lower()
    spam_keywords = ["follow", "marketing", "newsletter", "subscribe", "updates"]
    if any(kw in q_lower for kw in spam_keywords):
        logger.debug(f"Skipping spam checkbox: {question[:50]}")
        continue
    try:
        if not cb.is_checked():
            cb.check()
            logger.info(f"Fallback checkbox (checked): {question[:50]}")
    except Exception:
        pass
    continue
```

FIX 3 - answer_engine.py - Add these patterns to checkbox_patterns list:

```python
(r"sms|text\s*(message|communication)", "checkboxes", "sms_consent"),
(r"i\s*(understand|acknowledge|agree|certify|confirm)", "checkboxes", "acknowledgment"),
(r"consent", "checkboxes", "general_consent"),
```

And add to config/answers.yaml under checkboxes:
```yaml
sms_consent: false
acknowledgment: true
general_consent: true
```

Goal: Bot always fills SOMETHING for radio groups and acknowledgment checkboxes. Never leave required fields empty.

## Code Standards

Write code that looks inevitable. Follow these constraints:

**Restraint**
- Solve it in one file if possible
- No abstractions until the third time you need them
- No classes if functions will do
- No inheritance - use composition

**Functions**
- Max 25 lines, aim for 15
- One level of nesting max
- Name describes exactly what it does: `extract_billable_hours()` not `process_data()`
- Input → transform → output. No side effects unless that's the point.

**Files**
- Max 200 lines for new files
- One clear responsibility
- If you're adding a second "system" to a file, stop and split

**No Ceremony**
- No AbstractFactory, no IServiceProvider, no Manager classes
- No code "just in case" - solve the actual problem
- Delete commented-out code, don't keep it

**Data**
- Use dataclasses or plain dicts, not classes with only __init__ and getters
- Data flows obviously - reader should predict what happens next
- No global state

The best code is code you delete. Every line is a liability.
