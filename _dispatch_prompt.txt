Fix critical radio button and pattern matching bugs in LinkedIn form filler.

## BUGS FROM LOGS

### Bug 1: "city|location" pattern matching wrong questions
The question "Have you previously been employed by Coinbase in a location..." is matching the pattern `city|location` and returning "Lorain, Ohio" instead of being treated as a previous employment question.

The pattern is too broad. "location" appears in many contexts.

### Bug 2: Radio fallback defaults to "Yes" for dangerous questions
The fallback in `_fill_single_radio_group` selects the FIRST option, which is usually "Yes". This is answering:
- "Do you have a public Ethereum Address" → Yes (WRONG - should be No)
- "Do you or a close relative hold a role [conflict of interest]" → Yes (WRONG - should be No) 
- "Were you referred by a senior leader" → Yes (WRONG - should be No)
- "Have you previously been employed by Coinbase" → Yes (WRONG - should be No)

These false "Yes" answers can disqualify the application or create legal issues.

---

## FILES TO MODIFY

### 1. src/agent/answer_engine.py - Fix patterns and add "No" defaults

**Fix the city/location pattern to be more specific:**

Change from:
```python
(r"city|location", "personal", "city"),
```

To:
```python
(r"(?:your|current|preferred)\s*(?:city|location)|where.*(?:located|live|reside)|^city$|^location$", "personal", "city"),
```

**Add new patterns for questions that should default to "No":**

Add a new section `default_no_patterns` BEFORE checkbox_patterns:

```python
# Questions that should default to "No" - conflict of interest, previous employment, referrals
default_no_patterns = [
    # Previous employment
    (r"previously.*employed|former.*employee|worked.*(?:at|for|here).*before|been employed by", "default_no", "no"),
    # Referrals
    (r"referred.*(?:by|to)|referral|who referred", "default_no", "no"),
    # Conflict of interest
    (r"close relative.*(?:hold|have).*role|conflict.*interest|financial.*interest", "default_no", "no"),
    # Crypto/blockchain specific (don't have)
    (r"ethereum.*address|ens.*name|basename|wallet.*address|crypto.*(?:wallet|address)|smart.*contract", "default_no", "no"),
    # Government/political roles
    (r"government.*(?:official|employee)|political.*(?:office|role)|public.*official", "default_no", "no"),
    # Securities/regulatory
    (r"finra|sec.*registration|securities.*license|broker.*dealer", "default_no", "no"),
]
```

**Add to answers.yaml:**
```yaml
# Default "No" answers for sensitive questions
default_no:
  no: "No"
```

### 2. src/agent/linkedin_form_filler.py - Fix radio fallback logic

**Rewrite `_fill_single_radio_group()` to be smarter about defaults:**

```python
def _fill_single_radio_group(self, fieldset: Locator, question: str, strategy: str) -> bool:
    """Fill a single radio group with intelligent defaults."""
    answer = self._answers.get_answer(question, "radio")

    try:
        radios = fieldset.locator(LinkedInSelectors.RADIO).all()
    except Exception:
        return False

    if not radios:
        return False

    # Build label map
    radio_labels: list[tuple[Locator, str]] = []
    for radio in radios:
        label = self._get_radio_label(radio)
        radio_labels.append((radio, label.lower() if label else ""))

    # If we have an explicit answer, use it
    if answer is not None:
        answer_str = str(answer).lower()
        for radio, label in radio_labels:
            if label and answer_str in label:
                try:
                    if not radio.is_checked():
                        self._click_radio_label(radio)
                        logger.info(f"Radio [{strategy}]: {question[:40]} = {label}")
                except Exception:
                    pass
                return True

    # NO ANSWER - determine safe default based on question content
    q_lower = question.lower()
    
    # Questions that should default to "No"
    should_default_no = any(phrase in q_lower for phrase in [
        "previously employed", "former employee", "worked here before",
        "been employed by", "worked at", "worked for",
        "referred by", "referred to", "referral",
        "close relative", "conflict of interest", "financial interest",
        "ethereum", "ens", "basename", "wallet", "crypto", "smart contract",
        "government official", "political", "public official",
        "finra", "sec registration", "securities license", "broker",
        "convicted", "felony", "criminal",
        "non-compete", "non-disclosure",
        "lawsuit", "litigation", "legal action",
    ])
    
    # Questions that should default to "Yes"
    should_default_yes = any(phrase in q_lower for phrase in [
        "legally authorized", "authorized to work", "eligible to work",
        "background check", "drug test", "drug screen",
        "18 years", "over 18", "of age",
        "agree", "consent", "acknowledge", "certify", "confirm",
        "comfortable", "willing",
        "start immediately", "available to start",
    ])
    
    # Find Yes and No options
    yes_radio = None
    no_radio = None
    for radio, label in radio_labels:
        if label in ["yes", "true"]:
            yes_radio = radio
        elif label in ["no", "false"]:
            no_radio = radio
    
    # Apply default based on question type
    if should_default_no and no_radio:
        try:
            if not no_radio.is_checked():
                self._click_radio_label(no_radio)
                logger.info(f"Radio default NO [{strategy}]: {question[:40]}")
        except Exception:
            pass
        return True
    
    if should_default_yes and yes_radio:
        try:
            if not yes_radio.is_checked():
                self._click_radio_label(yes_radio)
                logger.info(f"Radio default YES [{strategy}]: {question[:40]}")
        except Exception:
            pass
        return True
    
    # Unknown question - default to "No" as safer option
    # (Better to under-claim than over-claim)
    if no_radio:
        try:
            if not no_radio.is_checked():
                self._click_radio_label(no_radio)
                logger.info(f"Radio fallback NO (safe default) [{strategy}]: {question[:40]}")
        except Exception:
            pass
        return True
    
    # Last resort - use first option
    if radios:
        first_radio = radios[0]
        first_label = self._get_radio_label(first_radio)
        try:
            if not first_radio.is_checked():
                self._click_radio_label(first_radio)
                logger.info(f"Radio fallback (first option) [{strategy}]: {question[:40]} = {first_label}")
        except Exception:
            pass
    
    return True
```

### 3. src/scraper/scorer.py - Filter out external jobs early (if not already done)

Check if the scorer already filters non-Easy-Apply jobs. If not, add filtering based on job_url patterns or apply_type field from JobSpy.

Look for a field like `is_remote_apply`, `easy_apply`, or `apply_type` in the job data and reject jobs that don't have Easy Apply.

---

## SUMMARY

1. **answer_engine.py**: Made `city|location` pattern more specific, added `default_no_patterns` for sensitive questions

2. **linkedin_form_filler.py**: Rewrote `_fill_single_radio_group()` with intelligent defaults:
   - Questions about previous employment/referrals/crypto → default No
   - Questions about work authorization/consent → default Yes  
   - Unknown questions → default No (safer)

3. Test against Coinbase-style forms with conflict of interest and crypto questions.

## Code Standards

Write code that looks inevitable. Follow these constraints:

**Restraint**
- Solve it in one file if possible
- No abstractions until the third time you need them
- No classes if functions will do
- No inheritance - use composition

**Functions**
- Max 25 lines, aim for 15
- One level of nesting max
- Name describes exactly what it does: `extract_billable_hours()` not `process_data()`
- Input → transform → output. No side effects unless that's the point.

**Files**
- Max 200 lines for new files
- One clear responsibility
- If you're adding a second "system" to a file, stop and split

**No Ceremony**
- No AbstractFactory, no IServiceProvider, no Manager classes
- No code "just in case" - solve the actual problem
- Delete commented-out code, don't keep it

**Data**
- Use dataclasses or plain dicts, not classes with only __init__ and getters
- Data flows obviously - reader should predict what happens next
- No global state

The best code is code you delete. Every line is a liability.
