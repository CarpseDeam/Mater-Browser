# Spec-Driven Implementation

## CRITICAL: TRUST THE SPEC

The specification below is COMPLETE. Do not:
- Read README, ARCHITECTURE, or documentation files
- Search for patterns or conventions in the codebase
- Explore directory structures
- Read files unrelated to your implementation

Only read files that:
1. You need to import from (check the target path's neighbors)
2. Contain types/classes referenced in the interface

The spec tells you exactly what to build. Trust it.

## CIRCUIT BREAKER

If you have made 8+ file reads without writing any code, STOP.
You are exploring instead of implementing. The spec is complete.
Write the implementation now with what you know.

## THE SPECIFICATION

# Specification: FailureSummarizer
Tier: FEATURE

## Description
Groups and ranks failures from the failure log for analysis. Key feature: fuzzy-groups similar question texts so "Years of Python experience?" and "How many years of Python?" are recognized as the same pattern.

## Interface
- `FailureSummary` dataclass with: failure_type, count, examples, grouped_questions (for unknown_question type)
- `FailureSummarizer.__init__(failures: list[ApplicationFailure])` — Initialize with failures to analyze
- `FailureSummarizer.summarize() -> list[FailureSummary]` — Group by type, rank by frequency, return top summaries
- `FailureSummarizer.get_top_unknown_questions(n: int = 10) -> list[tuple[str, int, list[str]]]` — Returns (canonical_question, count, [similar_questions])

## Must Do
- Group failures by failure_type first
- For `unknown_question` type: fuzzy-group similar question texts using difflib.SequenceMatcher (ratio > 0.7 = same group)
- Pick shortest question in each fuzzy group as canonical representative
- Sort summaries by count descending
- Include up to 3 example failures per summary for context
- Extract question_text from details dict for unknown_question grouping
- Handle missing/malformed details gracefully (skip, don't crash)

## Must Not Do
- No external dependencies (use stdlib difflib, not rapidfuzz)
- Don't load failures from disk - receives list in constructor
- Don't modify the input failures list

## Edge Cases
- Empty failures list → return empty list
- Failure missing details.question_text → skip from question grouping
- All failures are same type → single summary returned
- Single failure → summary with count=1

## Validation
- Tests: pytest tests/feedback/test_failure_summarizer.py -v

## Target Path
src/feedback/failure_summarizer.py

## YOUR TASK

**Tier: FEATURE** - Standard feature implementation.
- Full behavior test coverage
- All edge cases must be tested
- Contract tests for public interfaces

### Step 1: Implement the Interface

Implementation location: `src/feedback/failure_summarizer.py`

Implementation Rules:
1. Follow interface signatures EXACTLY as specified
2. Handle all edge cases as specified
3. Ensure preconditions are checked
4. Ensure postconditions are satisfied
5. Respect all 'Must Not Do' constraints

### Step 2: Write Tests

Test file location: `tests/test_failuresummarizer.py`

After implementing, write tests that verify contract and behavior:

**Must Do Tests:**
- Write one test for each item in the 'Must Do' section
- Tests should verify the behavior/contract, not implementation details

**Edge Case Tests:**
- Write one test for each edge case specified

Test Code Requirements:
- Use pytest fixtures for shared setup
- Include full type hints
- Use descriptive test names
- Keep tests focused and independent

### Step 3: Validate

Run validation: `pytest tests/feedback/test_failure_summarizer.py -v`

Iterate until all tests pass.
Maximum iterations: 5

Write clean, scalable, modular, efficient code. Follow single responsibility principle. Do not repeat yourself. Use consistent naming conventions. No unnecessary comments.